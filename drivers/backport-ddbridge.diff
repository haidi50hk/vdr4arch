--- dddvb-0.9.10/ddbridge/ddbridge-core.c	2013-10-08 12:16:16.000000000 +0200
+++ dddvb-0.9.10.modif/ddbridge/ddbridge-core.c	2014-02-21 22:34:59.937202388 +0100
@@ -23,7 +23,6 @@
 
 #include "ddbridge-mod.c"
 #include "ddbridge-i2c.c"
-#include "ddbridge-ns.c"
 
 
 static void ddb_set_dma_table(struct ddb *dev, struct ddb_dma *dma)
@@ -833,12 +832,6 @@
 /****************************************************************************/
 /****************************************************************************/
 
-static long mod_ioctl(struct file *file,
-		      unsigned int cmd, unsigned long arg)
-{
-	return dvb_usercopy(file, cmd, arg, ddbridge_mod_do_ioctl);
-}
-
 static const struct file_operations mod_fops = {
 	.owner   = THIS_MODULE,
 	.read    = ts_read,
@@ -847,7 +840,6 @@
 	.release = mod_release,
 	.poll    = ts_poll,
 	.mmap    = 0,
-	.unlocked_ioctl = mod_ioctl,
 };
 
 static struct dvb_device dvbdev_mod = {
@@ -2400,184 +2392,6 @@
 }
 
 
-/****************************************************************************/
-/****************************************************************************/
-/****************************************************************************/
-
-static ssize_t nsd_read(struct file *file, char *buf,
-			size_t count, loff_t *ppos)
-{
-	return 0;
-}
-
-static unsigned int nsd_poll(struct file *file, poll_table *wait)
-{
-	return 0;
-}
-
-static int nsd_release(struct inode *inode, struct file *file)
-{
-	return dvb_generic_release(inode, file);
-}
-
-static int nsd_open(struct inode *inode, struct file *file)
-{
-	return dvb_generic_open(inode, file);
-}
-
-static int nsd_do_ioctl(struct file *file, unsigned int cmd, void *parg)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct ddb *dev = dvbdev->priv;
-
-	unsigned long arg = (unsigned long) parg;
-	int ret = 0;
-
-	switch (cmd) {
-	case NSD_START_GET_TS:
-	{
-		struct dvb_nsd_ts *ts = parg;
-		u32 ctrl = ((ts->input & 7) << 8) | (ts->filter_mask << 2);
-		u32 to;
-		int i;
-		
-		if (ddbreadl(dev, TS_CAPTURE_CONTROL) & 1) {
-			printk("ts capture busy\n");
-			return -EBUSY;
-		}
-		ddb_dvb_input_start(&dev->input[ts->input & 7]);
-
-		ddbwritel(dev, ctrl, TS_CAPTURE_CONTROL);
-		ddbwritel(dev, ts->pid, TS_CAPTURE_PID);
-		ddbwritel(dev, (ts->section_id << 16) | (ts->table << 8) | ts->section,
-			  TS_CAPTURE_TABLESECTION);
-		/* 1024 ms default timeout if timeout set to 0 */
-		if (ts->timeout)
-			to = ts->timeout;
-		else
-			to = 1024;
-		/* 21 packets default if num set to 0 */
-		if (ts->num)
-			to |= ((u32) ts->num << 16);
-		else
-			to |= (21 << 16);
-		ddbwritel(dev, to, TS_CAPTURE_TIMEOUT);
-		if (ts->mode)
-			ctrl |= 2;
-		ddbwritel(dev, ctrl | 1, TS_CAPTURE_CONTROL);
-
-#if 0
-		for (i = 0; i < (ts->timeout / 100); i++) {
-			if (ddbreadl(dev, TS_CAPTURE_CONTROL) & 1)
-				msleep(100);
-			else
-				break;
-		}
-		//printk("ts capture done %d\n", i);
-		if ((ddbreadl(dev, TS_CAPTURE_CONTROL) & 1) ||
-		    (ddbreadl(dev, TS_CAPTURE_CONTROL) & (1 << 14))) {
-			//printk("ts capture timeout\n");
-			ddb_dvb_input_stop(&dev->input[ts->input & 7]);
-			return -EAGAIN;
-		}
-		ddb_dvb_input_stop(&dev->input[ts->input & 7]);
-		ddbcpyfrom(dev, dev->tsbuf, TS_CAPTURE_MEMORY, TS_CAPTURE_LEN);
-		ts->len = ddbreadl(dev, TS_CAPTURE_RECEIVED) & 0xfff;
-		ret = copy_to_user(ts->ts, dev->tsbuf, ts->len);
-		if (ret < 0)
-			return ret;
-#endif
-		break;
-	}
-	case NSD_POLL_GET_TS:
-	{
-		struct dvb_nsd_ts *ts = parg;
-		u32 ctrl = ddbreadl(dev, TS_CAPTURE_CONTROL);
-
-		if (ctrl & 1) {
-			return -EBUSY;
-		}
-		if (ctrl & (1 << 14)) {
-			//printk("ts capture timeout\n");
-			return -EAGAIN;
-		}
-		ddbcpyfrom(dev, dev->tsbuf, TS_CAPTURE_MEMORY, TS_CAPTURE_LEN);
-		ts->len = ddbreadl(dev, TS_CAPTURE_RECEIVED) & 0xfff;
-		if (copy_to_user(ts->ts, dev->tsbuf, ts->len) < 0)
-			return -EIO;
-		break;
-	}
-	case NSD_CANCEL_GET_TS:
-	{
-		u32 ctrl = 0;
-		printk("cancel ts capture: 0x%x\n", ctrl);
-		ddbwritel(dev, ctrl, TS_CAPTURE_CONTROL);
-		ctrl = ddbreadl(dev, TS_CAPTURE_CONTROL);
-		//printk("control register is 0x%x\n", ctrl);
-		break;
-	}
-	case NSD_STOP_GET_TS:
-	{
-		struct dvb_nsd_ts *ts = parg;
-		if (ddbreadl(dev, TS_CAPTURE_CONTROL) & 1) {
-			printk("cannot stop ts capture, while it was neither finished not canceled\n");
-			return -EBUSY;
-		}
-		//printk("ts capture stopped\n");
-		ddb_dvb_input_stop(&dev->input[ts->input & 7]);
- 		break;
- 	}
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	return ret;
-}
-
-static long nsd_ioctl(struct file *file,
-		      unsigned int cmd, unsigned long arg)
-{
-	return dvb_usercopy(file, cmd, arg, nsd_do_ioctl);
-}
-
-static const struct file_operations nsd_fops = {
-	.owner   = THIS_MODULE,
-	.read    = nsd_read,
-	.open    = nsd_open,
-	.release = nsd_release,
-	.poll    = nsd_poll,
-	.unlocked_ioctl = nsd_ioctl,
-};
-
-static struct dvb_device dvbdev_nsd = {
-	.priv    = 0,
-	.readers = 1,
-	.writers = 1,
-	.users   = 1,
-	.fops    = &nsd_fops,
-};
-
-static int ddb_nsd_attach(struct ddb *dev)
-{
-	int ret;
-
-	ret = dvb_register_device(&dev->adap[0],
-				  &dev->nsd_dev,
-				  &dvbdev_nsd, (void *) dev,
-				  DVB_DEVICE_NSD);
-	return ret;
-}
-
-static void ddb_nsd_detach(struct ddb *dev)
-{
-	if (dev->nsd_dev->users > 2) {
-		wait_event(dev->nsd_dev->wait_queue,
-			   dev->nsd_dev->users == 2);
-	}
-	dvb_unregister_device(dev->nsd_dev);
-}
-
-
 /******************************************************************************/
 /******************************************************************************/
 /******************************************************************************/
@@ -3235,7 +3049,6 @@
 static struct class ddb_class = {
 	.name		= "ddbridge",
 	.owner          = THIS_MODULE,
-	.dev_attrs	= ddb_attrs,
 	.devnode        = ddb_devnode,
 };
 
--- dddvb-0.9.10/ddbridge/ddbridge.h	2013-10-08 21:43:14.000000000 +0200
+++ dddvb-0.9.10.modif/ddbridge/ddbridge.h	2014-02-21 22:33:15.663867038 +0100
@@ -67,7 +67,6 @@
 #include <linux/device.h>
 #include <linux/io.h>
 
-#include "dvb_netstream.h"
 #include "dmxdev.h"
 #include "dvbdev.h"
 #include "dvb_demux.h"
@@ -167,7 +166,6 @@
 	struct dmxdev          dmxdev;
 	struct dvb_demux       demux;
 	struct dvb_net         dvbnet;
-	struct dvb_netstream   dvbns;
 	struct dmx_frontend    hw_frontend;
 	struct dmx_frontend    mem_frontend;
 	int                    users;
--- dddvb-0.9.10/ddbridge/Kbuild	2013-08-08 16:12:21.000000000 +0200
+++ dddvb-0.9.10.modif/ddbridge/Kbuild	2014-02-21 22:33:15.663867038 +0100
@@ -5,4 +5,5 @@
 
 EXTRA_CFLAGS += -Idrivers/media/dvb/frontends -Idrivers/media/dvb-frontends
 EXTRA_CFLAGS += -Idrivers/media/common/tuners 
-NOSTDINC_FLAGS += -I$(SUBDIRS)/frontends -I$(SUBDIRS)/include -I$(SUBDIRS)/dvb-core 
\ No newline at end of file
+NOSTDINC_FLAGS += -I$(SUBDIRS)/frontends -I$(SUBDIRS)/include -I$(SUBDIRS)/dvb-core 
+EXTRA_CFLAGS += -Idrivers/media/dvb-core -Idrivers/staging/media/cxd2099 -Iinclude/uapi/linux/dvb -Idrivers/media/tuners
\ No newline at end of file
